# -*- coding: utf-8 -*-
__version__ = "0.2021.12.10"
#__version__ = "0.2021.12.10"
#__title__ = "Joint Macro"
#__author__ = "<TheMarkster> 2021"
#__license__ = "LGPL 2.1"
#__doc__ = "Create a mortise/tenon joint, box joint, dovetail joint, ball joint, or split joint."
#__usage__ = '''Select the face and activate the tool, modify properties as desired'''
#import Part, FreeCADGui, FreeCAD
#from PySide import QtGui,QtCore
#import DraftGeomUtils as DGU
#import math
#
#class Joint:
#    def __init__(self,obj):
#        jointGroup = "Joint v."+__version__
#        obj.addProperty("App::PropertyString","AddSubType",jointGroup,"Additive, Subtractive type when using Part Design pattern tools -- set at time of object creation.")
#        obj.setEditorMode("AddSubType",1)#readonly
#        obj.addProperty("App::PropertyFloat", "Undercut","Cantilever","Cantilever undercut (readonly) calculated value")
#        obj.setEditorMode("Undercut",1) #readonly
#        obj.addProperty("App::PropertyFloatConstraint","SplitRadius","Split Joint","Radius of spheres").SplitRadius = (1,0.01,float("inf"),.1)
#        obj.addProperty("App::PropertyFloatConstraint","SplitSlotWidth","Split Joint","Width of slot in Split Joints").SplitSlotWidth = (2,0,float("inf"),.1)
#        obj.addProperty("App::PropertyFloatConstraint","SplitSlotFilletRadius","Split Joint","Radius of fillets at base of slot in Split Joints").SplitSlotFilletRadius = (.5,0.01,float("inf"),.1)
#        obj.addProperty("App::PropertyBool","SplitRounded","Split Joint", "Split Joints -- Whether to have a rounded end or a flat end").SplitRounded = True
#        obj.addProperty("App::PropertyFloatConstraint","BallRadius","Ball Joint","Ball joints only -- radius of the ball, in mm").BallRadius=(5,0,1e13,.1)
#        obj.addProperty("App::PropertyFloatConstraint","BallStemRadius","Ball Joint", "Ball joints only -- radius of stem connecting ball to face surface").BallStemRadius=(2,0,1e13,.1)
#        obj.addProperty("App::PropertyFloatConstraint","BallStemLength","Ball Joint", "Ball joints only -- length of stem connecting ball to face surface").BallStemLength=(2,0,1e13,.1)
#        obj.addProperty("App::PropertyIntegerConstraint","BallSlotCount","Ball Joint","Ball joints only -- count of slots cut from ball").BallSlotCount = (3,0,1000,1)
#        obj.addProperty("App::PropertyFloatConstraint","BallSlotThickness","Ball Joint","Ball joints only -- size of slot in mm").BallSlotThickness = (.5,0.0,float("inf"),.1)
#        obj.addProperty("App::PropertyFloatConstraint","BallFilletRadius","Ball Joint","Ball joints only -- radius of fillet (in mm) at stem base and ball base").BallFilletRadius = (0.5,0,1e13,.1)
#        obj.addProperty("App::PropertyFloatConstraint","BallSlotToolFilletRadius","Ball Joint","Ball joints only -- radius of fillet (in mm) at stem base and ball base").BallSlotToolFilletRadius = (0.1,0,1e13,.1)
#        obj.addProperty("App::PropertyFloatConstraint","BallSlotToolCoreRadius","Ball Joint","Ball joints only -- radius of slot cutting tool core cylinder").BallSlotToolCoreRadius = (0.5,0,1e13,.1)
#        obj.addProperty("App::PropertyFloatConstraint","BallSlotToolCoreSphereRadius","Ball Joint","Ball joints only -- radius of slot cutting tool core sphere").BallSlotToolCoreSphereRadius = (3.5,0,1e13,.1)
#        obj.addProperty("App::PropertyFloatConstraint","BallMateStart","Ball Joint","Ball joints only -- ratio from 0 to 1.0 for start of ball mate relative to ball diameter").BallMateStart = (0.33,0.01,1,.01)
#        obj.addProperty("App::PropertyFloatConstraint","BallSlotStart","Ball Joint","Ball joints only -- ratio from 0 to 1.0 for start of ball slot relative to ball diameter").BallSlotStart = (0.2,0,1,.01)
#        obj.addProperty("App::PropertyFloatConstraint","RadiusFactor","Cantilever","Radius factor * length = radius of filet at base").RadiusFactor =(0.6,-float("inf"),float("inf"),.1)
#        obj.addProperty("App::PropertyFloatConstraint","HeadSpaceAdjust","Cantilever","(Cantilever Mate only) adjusts the amount of free space between the hook nose tip and the mate back wall").HeadSpaceAdjust =(0,-float("inf"),float("inf"),.1)
#        obj.addProperty("App::PropertyFloat","UndercutAngle","Cantilever","(Cantilver only) adjust angle of undercut")
#        obj.addProperty("App::PropertyFloatConstraint","UndercutPositionTweak","Cantilever","(Cantilever only) adjust position of undercut").UndercutPositionTweak = (0,-float("inf"),float("inf"),.1)
#        obj.addProperty("App::PropertyFloatConstraint","SlotBottom","Annular","Annular Hook only - position of bottom of slot as ratio of overall height, default = 0.25").SlotBottom = (0.25,0,1,.05)
#        obj.addProperty("App::PropertyFloatConstraint","SlotToolFilletRadius","Annular","Annular Hook only - radius if fillets applied to slot cutting tool, default = .5").SlotToolFilletRadius = (.5,0,float("inf"),.1)
#        obj.addProperty("App::PropertyFloatConstraint","Scale",jointGroup,"Scale factor, default = 1.0 - be advised: what works at one scale might not work so well at another").Scale = (1.0,-float("inf"),float("inf"),.1)
#        obj.addProperty("App::PropertyFloatConstraint","SlotAngle","Annular","Annular Hook only - angle of slot cutting tool, e.g. 90 degrees would cut 1/4 of the way around").SlotAngle = (20,-360,360,1)
#        obj.addProperty("App::PropertyFloatConstraint","DiameterTweak","Annular","Annular types only - tweak diameter of revolved faces").DiameterTweak = (0,-float("inf"),float("inf"),.1)
#        obj.addProperty("App::PropertyIntegerConstraint","SlotCount","Annular","Annular Hook only - number of slots to cut").SlotCount = (6,0,100,1)
#        obj.addProperty("App::PropertyFloatConstraint","Taper","Cantilever","(Cantilever Hook) thickness of hook end compared to hook base, as a ratio.  default: 0.3").Taper = (0.3,0.01,1.0,0.01)
#        obj.addProperty("App::PropertyFloat","NoseAngle","Cantilever","Angle of cantilever hook nose, in degrees").NoseAngle = 60
#        obj.addProperty("App::PropertyFloatConstraint","MaterialDeflection","Cantilever","Permissible deflection of material, default = 2%").MaterialDeflection = (0.02,-float("inf"),float("inf"),.001)
#        obj.addProperty("App::PropertyFloatConstraint","CantileverMateClearance","Cantilever","Clearance for hook / mate.  Default 0.5 mm (for FDM), recommended 0.3 mm for other 3D printer types").CantileverMateClearance = (.5,-float("inf"),float("inf"),.1)
#        obj.addProperty("App::PropertyFloatConstraint","ShapeDeflection","Cantilever","Deflection factor for rectangular cross section cantilevers, default = 1.09").ShapeDeflection = (1.09,-float("inf"),float("inf"),.01)
#        obj.addProperty("App::PropertyEnumeration","JointType",jointGroup,"Type of joint to make").JointType=["Mortise","Tenon","Box Joint","Dovetail Joint","Cantilever Hook", "Cantilever Mate","Annular Hook", "Annular Mate","Ball Joint", "Ball Mate","Split Joint", "Split Mate"]
#        obj.addProperty("App::PropertyFloat","Depth","Dimensions","depth of joint below or above surface").Depth=5
#        obj.addProperty("App::PropertyVector","Position","Positioning","XYZ position adjustments (internal coordinate system)")
#        obj.addProperty("App::PropertyFloat","FingerWidth","Dimensions","Width of fingers (for Box Joints / Dovetail Joints only)").FingerWidth=5
#        obj.addProperty("App::PropertyFloat","FingerAngle","Dimensions","Angle of fingers in degrees (for Box Joints / Dovetail Joints only)").FingerAngle=30
#        obj.addProperty("App::PropertyFloat","FingerAngle2","Dimensions","Angle of fingers in degrees (for Box Joints / Dovetail Joints only)").FingerAngle2=30
#        obj.addProperty("App::PropertyFloat","BottomFilletAngle","Cantilever","(Cantilever Hook) angle where fillet meets angled edge of hook").BottomFilletAngle = 110
#        obj.addProperty("App::PropertyFloatConstraint","Width","Dimensions","width of joint").Width=(5,0.01,10e13,1)
#        obj.addProperty("App::PropertyFloatConstraint","Length","Dimensions","length of joint from tip of arc to tip of arc").Length=(5,1,10e13,1)
#        obj.addProperty("App::PropertyFloatConstraint","Offset","Dimensions","Clearance offset for adjusting the fit").Offset=(0,-10e13,10e13,.1)
#        obj.addProperty("App::PropertyLinkSub","Face",jointGroup,"Selected face for the joint")
#        obj.addProperty("App::PropertyBool","EditFace",jointGroup,"Trigger, toggle to bring up face editor").EditFace = False
#        obj.addProperty("App::PropertyBool","Boolean",jointGroup,"Whether to fuse with or cut from base feature").Boolean = True
#        obj.addProperty("App::PropertyBool","Symmetric","Positioning","Symmetric to plane (at depth in both directions)").Symmetric = True
#        obj.addProperty("App::PropertyBool","Reversed","Positioning","Extrude in oppositie direction if True").Reversed = False
#        obj.addProperty("App::PropertyBool","UseOdd","Positioning","(Box Joints / Dovetails only) cut odd fingers if True, else cut even fingers").UseOdd = False
#        obj.addProperty("App::PropertyBool","ShowTool","Positioning","To aid in positioning the cutting tool set this temporarily to True\nSet back to False after positioning tool to create the joint.").ShowTool = False
#        obj.addProperty("App::PropertyFloatConstraint","Angle","Positioning","Rotation angle (in degrees) about the local Z axis").Angle = (0,-360,360,1)
#        obj.addProperty("App::PropertyFloatConstraint","AngleX","Positioning","Rotation angle (in degrees) about the local X axis").AngleX = (0,-360,360,1)
#        obj.addProperty("App::PropertyFloatConstraint","AngleY","Positioning","Rotation angle (in degrees) about the local Y axis").AngleY = (0,-360,360,1)
#        if not hasattr(obj,"Refine"):
#            obj.addProperty("App::PropertyBool","Refine", jointGroup, "refine feature").Refine = False
#        obj.addProperty("App::PropertyBool","ClaimChildren",jointGroup,"whether to claim children in the tree").ClaimChildren = True
#        obj.setEditorMode("Placement",2) #hidden
#        self.editingMode = False
#        self.fpName = obj.Name
#        obj.Proxy = self
#
#    def recompute(self):
#        t = QtCore.QTimer()
#        t.singleShot(50,FreeCAD.ActiveDocument.recompute)
#
#    def onBeforeChange(self,fp,prop):
#        pass
#
#    def onChanged(self,fp,prop):
#        if prop == "EditFace" and fp.EditFace == True:
#            t = QtCore.QTimer()
#            t.singleShot(50, self.editFace) #avoid warning message about selection changing while committing data
#            fp.EditFace = False
#
#    def editFace(self):
#        fp = FreeCAD.ActiveDocument.getObject(self.fpName)
#        if not fp.Face:
#            return
#        object = fp.Face[0]
#        if not object:
#            return
#        if not FreeCADGui.Control.activeDialog():
#            panel = TaskEditLinkSubPanel(fp,"Face","Face")
#            FreeCADGui.Control.showDialog(panel)
#            self.editingMode = True #tells execute() not to hide the linked object
#        else:
#            self.editingMode=False
#            FreeCAD.Console.PrintError("Another task dialog is active.  Close that one and try again.\n")
#
#    def hideThem(self,fp,proplist,hide=True):
#        for prop in proplist:
#            mode = 2 if hide else 0
#            fp.setEditorMode(prop,mode)
#
#    def hideProps(self,fp):
#        '''hide properties unrelated to this type of joint'''
#        splitProps = ["SplitRadius","SplitSlotWidth","SplitSlotFilletRadius","SplitRounded"]
#        fingerProps = ["FingerAngle","FingerAngle2","FingerWidth","UseOdd",]
#        dovetailProps = ["FingerAngle","FingerAngle2"]
#        cantileverProps = ["Taper","UndercutAngle","UndercutPositionTweak","HeadSpaceAdjust","BottomFilletAngle","CantileverMateClearance","MaterialDeflection","NoseAngle","RadiusFactor","ShapeDeflection","Undercut"]
#        notLatchProps = ["Offset"]
#        annularProps = ["SlotToolFilletRadius","DiameterTweak","SlotAngle","SlotBottom","SlotCount"]
#        notAnnularProps = ["Width"]
#        notBallProps = ["Width","Length","Depth"]
#        ballProps = ["BallSlotToolCoreRadius","BallSlotToolCoreSphereRadius","BallRadius","BallStemRadius","BallStemLength","BallSlotCount","BallSlotThickness","BallFilletRadius","BallSlotToolFilletRadius","BallMateStart","BallSlotStart"]
#        if fp.JointType in ["Mortise","Tenon"]:
#            self.hideThem(fp,splitProps, True)
#            self.hideThem(fp,notBallProps,False)
#            self.hideThem(fp,ballProps,True)
#            self.hideThem(fp,notAnnularProps,False)
#            self.hideThem(fp,annularProps,True)
#            self.hideThem(fp,fingerProps,True)
#            self.hideThem(fp,cantileverProps, True)
#            self.hideThem(fp,notLatchProps,False)
#        elif "Split" in fp.JointType:
#            self.hideThem(fp,splitProps, False)
#            self.hideThem(fp,notBallProps,False)
#            self.hideThem(fp,ballProps,True)
#            self.hideThem(fp,notAnnularProps,False)
#            self.hideThem(fp,annularProps,True)
#            self.hideThem(fp,fingerProps,True)
#            self.hideThem(fp,dovetailProps,True)
#            self.hideThem(fp,cantileverProps, True)
#            self.hideThem(fp,notLatchProps,False)
#        elif fp.JointType == "Box Joint":
#            self.hideThem(fp,splitProps, True)
#            self.hideThem(fp,notBallProps,False)
#            self.hideThem(fp,ballProps,True)
#            self.hideThem(fp,notAnnularProps,False)
#            self.hideThem(fp,annularProps,True)
#            self.hideThem(fp,fingerProps,False)
#            self.hideThem(fp,dovetailProps,True)
#            self.hideThem(fp,cantileverProps, True)
#            self.hideThem(fp,notLatchProps,False)
#        elif fp.JointType == "Dovetail Joint":
#            self.hideThem(fp,splitProps, True)
#            self.hideThem(fp,notBallProps,False)
#            self.hideThem(fp,ballProps,True)
#            self.hideThem(fp,notAnnularProps,False)
#            self.hideThem(fp,annularProps,True)
#            self.hideThem(fp,fingerProps,False)
#            self.hideThem(fp,dovetailProps,False)
#            self.hideThem(fp,cantileverProps, True)
#            self.hideThem(fp,notLatchProps,False)
#        elif "Cantilever" in fp.JointType:
#            self.hideThem(fp,splitProps, True)
#            self.hideThem(fp,notBallProps,False)
#            self.hideThem(fp,ballProps,True)
#            self.hideThem(fp,notAnnularProps,False)
#            self.hideThem(fp,annularProps,True)
#            self.hideThem(fp,fingerProps,True)
#            self.hideThem(fp,dovetailProps,True)
#            self.hideThem(fp,cantileverProps, False)
#            self.hideThem(fp,notLatchProps,True)
#        elif "Annular" in fp.JointType:
#            self.hideThem(fp,splitProps, True)
#            self.hideThem(fp,notBallProps,False)
#            self.hideThem(fp,ballProps,True)
#            self.hideThem(fp,notAnnularProps,True)
#            self.hideThem(fp,annularProps,False)
#            self.hideThem(fp,fingerProps,True)
#            self.hideThem(fp,dovetailProps,True)
#            self.hideThem(fp,cantileverProps, False)
#            self.hideThem(fp,notLatchProps,True)
#        elif "Ball" in fp.JointType:
#            self.hideThem(fp,splitProps, True)
#            self.hideThem(fp,notBallProps,True)
#            self.hideThem(fp,ballProps,False)
#            self.hideThem(fp,annularProps,True)
#            self.hideThem(fp,fingerProps,True)
#            self.hideThem(fp,dovetailProps,True)
#            self.hideThem(fp,cantileverProps, True)
#            self.hideThem(fp,notLatchProps,True)
#
#    def execute(self,fp):
#        if not fp.Face:
#            return
#        self.hideProps(fp)
#        fp.Label2 = "("+fp.JointType+")"
#        object = fp.Face[0]
#        if not object:
#            return
#        face = object.getSubObject(fp.Face[1][0])
#        if fp.JointType == "Mortise" or fp.JointType == "Tenon":
#            shape = self.makeMortiseTenon(fp)
#        elif fp.JointType == "Box Joint":
#            shape = self.makeBoxJoint(fp)
#        elif fp.JointType == "Dovetail Joint":
#            shape = self.makeDovetailJoint(fp)
#        elif fp.JointType == "Cantilever Hook":
#            shape = self.makeCantileverHook(fp)
#        elif fp.JointType == "Cantilever Mate":
#            shape = self.makeCantileverMate(fp)
#        elif fp.JointType == "Annular Hook":
#            shape = self.makeAnnularHook(fp)
#        elif fp.JointType == "Annular Mate":
#            shape = self.makeAnnularMate(fp)
#        elif fp.JointType == "Ball Joint":
#            shape = self.makeBallJoint(fp)
#        elif fp.JointType == "Ball Mate":
#            shape = self.makeBallMate(fp)
#        elif fp.JointType == "Split Joint":
#            shape = self.makeSplitJoint(fp)
#        elif fp.JointType == "Split Mate":
#            shape = self.makeSplitJoint(fp,True)
#        else:
#            FreeCAD.Console.PrintError(f"Unsupported joint type: {fp.JointType}\n")
#            return
#        shape = shape.scale(fp.Scale) if fp.Scale != 1.0 else shape
##       thanks to openBrain on the FreeCAD forum for this next line of code
#        shape.Placement = fp.Placement.multiply(FreeCAD.Placement(face.CenterOfMass, FreeCAD.Rotation(FreeCAD.Vector(0,0,1),face.Surface.Axis)))
#        if fp.JointType == "Tenon" or fp.ShowTool or fp.JointType == "Cantilever Hook" or fp.JointType == "Annular Hook" or fp.JointType == "Ball Joint" or fp.JointType == "Split Joint":
#            full_shape = object.Shape.fuse(shape) if fp.Boolean else shape
#        else: #other types all require cuts
#            full_shape = object.Shape.cut(shape) if fp.Boolean else shape
#        fp.Shape = full_shape.removeSplitter() if fp.Refine else full_shape
#        if hasattr(fp,"BaseFeature") and hasattr(fp,"AddSubShape"):
#            if fp.BaseFeature and not shape.isNull():
#                fp.AddSubShape = shape.transformShape(fp.Placement.inverse().toMatrix(),True)
#            else:
#                fp.AddSubShape = shape
#        if not self.editingMode:
#            object.ViewObject.Visibility = False if shape and fp.Boolean else True
#
#    def makeSplitJoint(self,fp,makeMate = False):
#        ##Length is also the diameter of the rounded nose
#        width = fp.Width + fp.Offset
#        length = fp.Length + fp.Offset
#        depth = fp.Depth + fp.Offset
#        noseRadius = length/2
#        splitRadius = fp.SplitRadius + fp.Offset
#        splitSlotFilletRadius = fp.SplitSlotFilletRadius + fp.Offset
#        ## points
#        bottomFrontLeft = FreeCAD.Vector(-width/2, -length/2, 0)
#        topFrontLeft = FreeCAD.Vector(-width/2, -length/2, depth)
#        topBackLeft = FreeCAD.Vector(-width/2,length/2, depth)
#        bottomBackLeft = FreeCAD.Vector(-width/2, length/2, 0)
#        ballCenterLeft = FreeCAD.Vector(-width/2, 0, depth - noseRadius)
#        frontArcLeft = FreeCAD.Vector(-width/2, -length/2, depth - noseRadius)
#        topArcLeft = FreeCAD.Vector(-width/2, 0, depth)
#        backArcLeft = FreeCAD.Vector(-width/2, length/2, depth - noseRadius)
#        if fp.SplitRounded:
#            frontBottomLine = Part.makeLine(bottomFrontLeft, frontArcLeft)
#            arc = Part.ArcOfCircle(frontArcLeft, topArcLeft, backArcLeft).toShape()
#            backBottomLine = Part.makeLine(backArcLeft, bottomBackLeft)
#            bottomLine = Part.makeLine(bottomBackLeft, bottomFrontLeft)
#            wire = Part.Wire([frontBottomLine, arc, backBottomLine, bottomLine])
#        else:
#            frontLine = Part.makeLine(bottomFrontLeft, topFrontLeft)
#            topLine = Part.makeLine(topFrontLeft, topBackLeft)
#            backLine = Part.makeLine(topBackLeft, bottomBackLeft)
#            bottomLine = Part.makeLine(bottomBackLeft, bottomFrontLeft)
#            wire = Part.Wire([frontLine, topLine, backLine, bottomLine])
#        face = Part.makeFace(wire, "Part::FaceMakerCheese")
#        extrude = face.extrude(FreeCAD.Vector(1,0,0)*width/2)
#        if not makeMate and fp.SplitSlotWidth != 0:
#            extrude = face.extrude(FreeCAD.Vector(1,0,0)*(width/2 - fp.SplitSlotWidth/2))
#        sphere = Part.makeSphere(splitRadius, ballCenterLeft, FreeCAD.Vector(1,0,0),0,90,360)
#        sphere.Placement.rotate(ballCenterLeft, FreeCAD.Vector(0,-1,0),180)
#        extrude = extrude.fuse(sphere)
#        filletTop = extrude.Vertex2.Point.add(FreeCAD.Vector(0,0,splitSlotFilletRadius))
#        filletMiddle = extrude.Vertex2.Point.add(FreeCAD.Vector(splitSlotFilletRadius, 0, splitSlotFilletRadius))
#        filletBottom = extrude.Vertex2.Point.add(FreeCAD.Vector(splitSlotFilletRadius, 0, 0))
#        filletArc = Part.makeCircle(splitSlotFilletRadius, filletMiddle, FreeCAD.Vector(0,1,0),90,180)
#        filletBottomLine = Part.makeLine(filletBottom, extrude.Vertex2.Point)
#        filletLeftLine = Part.makeLine(extrude.Vertex2.Point, filletTop)
#        filletWire = Part.Wire([filletLeftLine,filletArc,filletBottomLine])
#        filletFace = Part.makeFace(filletWire,"Part::FaceMakerCheese")
#        fillet = filletFace.extrude(FreeCAD.Vector(0,1,0)*length)
#        mid = extrude.Edge1.CenterOfMass
#        if not makeMate and fp.SplitSlotWidth != 0:
#            fillet = fillet.fuse(fillet.mirror(mid,FreeCAD.Vector(1,0,0)))
#        else:
#            fillet = fillet.mirror(mid,FreeCAD.Vector(1,0,0))
#        extrude = extrude.fuse(fillet)
#        extrude = extrude.fuse(extrude.mirror(FreeCAD.Vector(0,0,0), FreeCAD.Vector(1,0,0)))
#        mirror = extrude.mirror(FreeCAD.Vector(0,0,0),FreeCAD.Vector(0,0,1))
#        if fp.Symmetric:
#            fusion = extrude.fuse(mirror)
#        elif fp.Reversed:
#            fusion = mirror
#        else:
#            fusion = extrude
#        cog = FreeCAD.Vector(0,0,0)
#        fusion.rotate(cog,FreeCAD.Vector(0,0,1),fp.Angle)
#        fusion = fusion.transformShape(fusion.Placement.toMatrix(),True)
#        fusion.Placement = FreeCAD.Placement()
#        fusion.rotate(cog,FreeCAD.Vector(0,1,0),fp.AngleY)
#        fusion = fusion.transformShape(fusion.Placement.toMatrix(),True)
#        fusion.Placement = FreeCAD.Placement()
#        fusion.rotate(cog,FreeCAD.Vector(1,0,0),fp.AngleX)
#        fusion = fusion.transformShape(fusion.Placement.toMatrix(),True)
#        fusion.Placement = FreeCAD.Placement()
#        fusion.Placement.move(fp.Position)
#        fusion = fusion.transformShape(fusion.Placement.toMatrix(),True)
#        fusion.Placement = FreeCAD.Placement()
#        return fusion
#
#    def makeBoxJoint(self,fp):
#        '''make the box joint shape'''
#        num = fp.Width / (fp.FingerWidth)
#        num = int(math.ceil(num))
#        boxes = []
#        depth = fp.Depth if not fp.Symmetric else fp.Depth*2
#        for n in range(0,num):
#            if bool(n % 2 == 0 and fp.UseOdd) or bool(n % 2 == 1 and not fp.UseOdd):
#                continue
#            x = -fp.Offset -fp.Width/2 + n * fp.FingerWidth
#            y = -fp.Offset -fp.Length/2
#            z = 0 if not fp.Symmetric else -fp.Depth
#            z = -fp.Depth if fp.Reversed else z
#            pt = FreeCAD.Vector(x,y,z).add(fp.Position)
#            boxes.append(Part.makeBox(fp.FingerWidth+fp.Offset*2, fp.Length+fp.Offset, depth+fp.Offset*2,pt-FreeCAD.Vector(0,0,fp.Offset*2)))
#        fusion = boxes[0].fuse(boxes[1:]) if len(boxes) > 1 else boxes[0]
#        fusion.rotate(FreeCAD.Vector(0,0,0),FreeCAD.Vector(0,0,1),fp.Angle)
#        fusion = fusion.transformShape(fusion.Placement.toMatrix(),True)
#        fusion.rotate(FreeCAD.Vector(0,0,-fp.Depth/2),FreeCAD.Vector(0,1,0),fp.AngleY)
#        fusion = fusion.transformShape(fusion.Placement.toMatrix(),True)
#        fusion.rotate(FreeCAD.Vector(0,0,-fp.Depth/2),FreeCAD.Vector(1,0,0),fp.AngleX)
#        fusion = fusion.transformShape(fusion.Placement.toMatrix(),True)
#        return fusion
#
#    def makeWedge(self, fp, wid, length, ht, pt):
#        '''support 2 angles for compound dovetails'''
#        tanht = math.tan(math.radians(-fp.FingerAngle/2)) * ht / 2
#        tanlength = math.tan(math.radians(-fp.FingerAngle2/2)) * length / 2
#        frontLeftBottom = FreeCAD.Vector(-tanht,0,0)
#        frontLeftTop = FreeCAD.Vector(tanht,0, ht)
#        frontLeft = Part.makeLine(frontLeftBottom, frontLeftTop)
#        topLeftBack = FreeCAD.Vector(tanht + tanlength, length, ht)
#        topLeft = Part.makeLine(frontLeftTop, topLeftBack)
#        topLeftDirection = topLeft.Vertex2.Point.sub(topLeft.Vertex1.Point)
#        backLeftBottom = frontLeftBottom.add(topLeftDirection)
#        backLeft = Part.makeLine(topLeftBack,backLeftBottom)
#        bottomLeft = Part.makeLine(frontLeftBottom, backLeftBottom)
#        leftWire = Part.Wire([bottomLeft,backLeft,topLeft,frontLeft])
#        leftFace = Part.makeFace(leftWire,"Part::FaceMakerCheese")
#        mirror = leftFace.mirror(FreeCAD.Vector(wid/2+leftFace.CenterOfMass.x,0,0),FreeCAD.Vector(1,0,0))
#        loft = Part.makeLoft([leftWire,mirror.Wire1],True)
#        loft.Placement.move(pt)
#        symmetric_mirror = loft.mirror(pt,FreeCAD.Vector(0,0,1))
#        if fp.Symmetric:
#            return loft.fuse(symmetric_mirror)
#        if not fp.Reversed:
#            return symmetric_mirror
#        else:
#            return loft
#
#    def makeDovetailJoint(self,fp):
#        '''make the dovetial joint shape'''
#        num = fp.Width / (fp.FingerWidth)
#        num = int(math.ceil(num))
#        wedges = []
#        for n in range(-1,num+1):
#            if bool(n % 2 == 0 and fp.UseOdd) or bool(n % 2 == 1 and not fp.UseOdd):
#                continue
#            x = -fp.Offset -fp.Width/2 + n * fp.FingerWidth
#            y = -fp.Offset -fp.Length/2
#            z = 0
#            pt = FreeCAD.Vector(x,y,z).add(fp.Position)
#            wedges.append(self.makeWedge(fp, fp.FingerWidth+fp.Offset*2, fp.Length+fp.Offset, fp.Depth+fp.Offset,pt))
#        fusion = wedges[0].fuse(wedges[1:]) if len(wedges) > 1 else wedges[0]
#        fusion.rotate(FreeCAD.Vector(0,0,-fp.Depth/2),FreeCAD.Vector(0,0,1),fp.Angle)
#        fusion = fusion.transformShape(fusion.Placement.toMatrix(),True)
#        fusion.rotate(FreeCAD.Vector(0,0,-fp.Depth/2),FreeCAD.Vector(0,1,0),fp.AngleY)
#        fusion = fusion.transformShape(fusion.Placement.toMatrix(),True)
#        fusion.rotate(FreeCAD.Vector(0,0,-fp.Depth/2),FreeCAD.Vector(1,0,0),fp.AngleX)
#        fusion = fusion.transformShape(fusion.Placement.toMatrix(),True)
#        return fusion
#
#    def makeCantileverHookFace(self,fp):
#        length = fp.Length #h in diagram
#        depth = fp.Depth #length in diagram
#        angle = fp.NoseAngle
#        radius = fp.RadiusFactor * length #default = 0.6 * length
#        undercut = fp.ShapeDeflection * fp.MaterialDeflection * depth * depth / length
#        fp.Undercut = undercut
#        upt = fp.UndercutPositionTweak
#        uat = math.tan(math.radians(fp.UndercutAngle))*undercut #undercut angle tweak
#        baseline = length + radius + radius #bottom of bottom fillet to top of top fillet
#        ## Points
#        filletCenterBottom = FreeCAD.Vector(radius, -baseline/2, 0)
#        filletCenterTop = FreeCAD.Vector(radius, baseline/2, 0)
#        baselineBottom = FreeCAD.Vector(0, -baseline/2, 0)
#        baselineTop = FreeCAD.Vector(0, baseline/2, 0)
#        undercutBottom = FreeCAD.Vector(uat + upt + radius + depth, length/2, 0)
#        undercutTop = FreeCAD.Vector(upt + radius + depth, length/2 + undercut, 0)
#        undercutRight = FreeCAD.Vector(radius + depth + undercut, length/2 + undercut, 0)
#        noseBottomY = -length/2 + (1-fp.Taper) * length
#        noseBottom = FreeCAD.Vector(radius + depth + undercut + math.tan(math.radians(angle))*undercut, noseBottomY, 0)
#        noseTop = FreeCAD.Vector(radius + depth + undercut + math.tan(math.radians(angle))*undercut, length/2, 0)
#        ## Edges
#        bottomArc = Part.makeCircle(radius,filletCenterBottom,FreeCAD.Vector(0,0,1),fp.BottomFilletAngle,180)
#        topArc = Part.makeCircle(radius,filletCenterTop,FreeCAD.Vector(0,0,1),180,270)
#        hookBottom = Part.makeLine(bottomArc.Vertex1.Point, noseBottom)
#        hookNoseBottom = Part.makeLine(noseBottom, noseTop)
#        hookNoseSlant = Part.makeLine(noseTop, undercutRight)
#        hookNoseTop = Part.makeLine(undercutRight, undercutTop)
#        hookNoseLeft = Part.makeLine(undercutTop, undercutBottom)
#        hookTop = Part.makeLine(undercutBottom, topArc.Vertex2.Point)
#        hookBaseline = Part.makeLine(topArc.Vertex1.Point,bottomArc.Vertex2.Point)
#        wire = Part.Wire([hookBaseline, topArc, hookTop, hookNoseLeft, hookNoseTop, hookNoseSlant, hookNoseBottom, hookBottom, bottomArc])
#        face = Part.makeFace(wire,"Part::FaceMakerCheese")
#        return face
#
#    def makeBallJoint(self,fp):
#        ## points
#        bottomLeft = FreeCAD.Vector(-fp.BallStemRadius - fp.BallFilletRadius, 0, 0)
#        arcCenter = FreeCAD.Vector(-fp.BallStemRadius - fp.BallFilletRadius, 0, fp.BallFilletRadius)
#        filletTop = FreeCAD.Vector(-fp.BallStemRadius,0,fp.BallFilletRadius)
#        sagitta = fp.BallRadius - math.sqrt(fp.BallRadius**2 - fp.BallStemRadius**2)
#        ballBottomLeft = FreeCAD.Vector(-fp.BallStemRadius, 0, fp.BallStemLength+sagitta)
#        ballLeft = FreeCAD.Vector(-fp.BallRadius,0,fp.BallStemLength + fp.BallRadius)
#        ballTop = FreeCAD.Vector(0,0,fp.BallStemLength + fp.BallRadius + fp.BallRadius)
#        bottomRight = FreeCAD.Vector(0,0,0)
#
#       ## edges
#        bottom = Part.makeLine(bottomRight,bottomLeft)
#        filletArc = Part.makeCircle(fp.BallFilletRadius, arcCenter, FreeCAD.Vector(0,1,0),0, 90)
#        stemLeft = Part.makeLine(filletTop, ballBottomLeft)
#        ball = Part.ArcOfCircle(ballBottomLeft,ballLeft,ballTop)
#        rightSide = Part.makeLine(ballTop,bottomRight)
#
#        wire = Part.Wire([bottom,filletArc,stemLeft,ball.toShape().Edge1,rightSide])
#        face = Part.makeFace(wire,"Part::FaceMakerCheese")
#        revolve = face.revolve(bottomRight, FreeCAD.Vector(0,0,1),180)
#        revolve = revolve.makeFillet(fp.BallFilletRadius,[revolve.Edge7])
#        revolve = revolve.fuse(revolve.mirror(FreeCAD.Vector(0,0,0), FreeCAD.Vector(0,1,0)))
#        ## cut slots in ball
#        btPos = fp.BallStemLength + fp.BallSlotStart * (2*fp.BallRadius)
#        thick = fp.BallSlotThickness
#        centerEdge = Part.makeLine(FreeCAD.Vector(-fp.BallRadius*2,-thick/2,btPos),FreeCAD.Vector(-fp.BallRadius*2,-thick/2,fp.BallStemLength+3*fp.BallRadius))
#        topEdge = Part.makeLine(FreeCAD.Vector(-fp.BallRadius*2,-thick/2,fp.BallStemLength+3*fp.BallRadius),FreeCAD.Vector(fp.BallRadius*2,-thick/2,fp.BallStemLength+3*fp.BallRadius))
#        rightEdge = Part.makeLine(FreeCAD.Vector(fp.BallRadius*2,-thick/2,fp.BallStemLength+3*fp.BallRadius),FreeCAD.Vector(fp.BallRadius*2,-thick/2,btPos))
#        bottomEdge = Part.makeLine(FreeCAD.Vector(-fp.BallRadius*2,-thick/2,btPos),FreeCAD.Vector(fp.BallRadius*2,-thick/2,btPos))
#        wire = Part.Wire([centerEdge,topEdge,rightEdge,bottomEdge])
#        face = Part.makeFace(wire,"Part::FaceMakerCheese")
#        slotTool = face.extrude(FreeCAD.Vector(0,thick,0))
#        slotTool = slotTool.makeFillet(fp.BallSlotToolFilletRadius,[slotTool.Edge6,slotTool.Edge7,slotTool.Edge11,slotTool.Edge12])
#        if fp.BallSlotToolCoreSphereRadius >= fp.BallRadius:
#            FreeCAD.Console.PrintError("Ball joint core tool sphere radius must be smaller than ball radius.\n")
#        if not fp.BallSlotToolCoreRadius == 0:
#            core = Part.makeCylinder(fp.BallSlotToolCoreRadius,fp.BallStemLength+3*fp.BallRadius,FreeCAD.Vector(0,0,btPos-.01))
#            coreSphere = Part.makeSphere(fp.BallSlotToolCoreSphereRadius,FreeCAD.Vector(0,0,fp.BallStemLength+fp.BallRadius)) if fp.BallSlotToolCoreSphereRadius != 0 else Part.Shape()
#            toolCopies = core.fuse(coreSphere) if not coreSphere.isNull() else core
#        else:
#            toolCopies = Part.Shape()
#        for ii in range(0,fp.BallSlotCount):
#            copy = slotTool.copy()
#            copy.rotate(FreeCAD.Vector(0,0,0),FreeCAD.Vector(0,0,1), ii * (180 / fp.BallSlotCount))
#            if toolCopies.isNull():
#                toolCopies = copy
#            else:
#                toolCopies = toolCopies.fuse(copy)
#        toolCopies = toolCopies.removeSplitter() if not toolCopies.isNull() else toolCopies
#        if not toolCopies.isNull():
#            revolve = revolve.cut(toolCopies)
#        mirror = revolve.mirror(FreeCAD.Vector(0,0,0),FreeCAD.Vector(0,0,1))
#        if fp.Symmetric:
#            revolve = revolve.fuse(mirror)
#        elif fp.Reversed:
#            revolve = mirror
#        cog = mirror.Face1.CenterOfGravity
#        revolve.rotate(cog,FreeCAD.Vector(0,0,1),fp.Angle)
#        revolve = revolve.transformShape(revolve.Placement.toMatrix(),True)
#        revolve.Placement = FreeCAD.Placement()
#        revolve.rotate(cog,FreeCAD.Vector(0,1,0),fp.AngleY)
#        revolve = revolve.transformShape(revolve.Placement.toMatrix(),True)
#        revolve.Placement = FreeCAD.Placement()
#        revolve.rotate(cog,FreeCAD.Vector(1,0,0),fp.AngleX)
#        revolve = revolve.transformShape(revolve.Placement.toMatrix(),True)
#        revolve.Placement = FreeCAD.Placement()
#        revolve.Placement.move(fp.Position)
#        revolve = revolve.transformShape(revolve.Placement.toMatrix(),True)
#        revolve.Placement = FreeCAD.Placement()
#        return revolve
#
#    def makeBallMate(self,fp):
#        #ballProps = ["BallRadius","BallStemRadius","BallStemLength",\
#        #"BallSlotCount","BallSlotThickness","BallFilletRadius","BallSlotToolFilletRadius",\
#        #"BallMateStart","BallSlotStart"]
#        sphere = Part.makeSphere(fp.BallRadius, FreeCAD.Vector(0,0,fp.BallStemLength+fp.BallRadius))
#        start = fp.BallStemLength + fp.BallMateStart * (fp.BallRadius * 2)
#        circle = Part.makeCircle(fp.BallRadius, FreeCAD.Vector(0,0,start),FreeCAD.Vector(0,0,1))
#        face = Part.makeFace(circle, "Part::FaceMakerCheese")
#        extrude = face.extrude(FreeCAD.Vector(0,0,-1))
#        common = extrude.common(sphere)
#        r1 = common.Edge1.Curve.Radius
#        cylinder = Part.makeCylinder(r1,start)
#        fusion = cylinder.fuse(sphere)
#        mirror = fusion.mirror(FreeCAD.Vector(0,0,0),FreeCAD.Vector(0,0,1))
#        if fp.Symmetric:
#            fusion = fusion.fuse(mirror)
#        elif fp.Reversed:
#            fusion = mirror
#        cog = mirror.Face1.CenterOfGravity
#        fusion.rotate(cog,FreeCAD.Vector(0,0,1),fp.Angle)
#        fusion = fusion.transformShape(fusion.Placement.toMatrix(),True)
#        fusion.Placement = FreeCAD.Placement()
#        fusion.rotate(cog,FreeCAD.Vector(0,1,0),fp.AngleY)
#        fusion = fusion.transformShape(fusion.Placement.toMatrix(),True)
#        fusion.Placement = FreeCAD.Placement()
#        fusion.rotate(cog,FreeCAD.Vector(1,0,0),fp.AngleX)
#        fusion = fusion.transformShape(fusion.Placement.toMatrix(),True)
#        fusion.Placement = FreeCAD.Placement()
#        fusion.Placement.move(fp.Position)
#        fusion = fusion.transformShape(fusion.Placement.toMatrix(),True)
#        fusion.Placement = FreeCAD.Placement()
#        return fusion
#
#    def makeAnnularHook(self,fp):
#        face = self.makeCantileverHookFace(fp)
#        direction = FreeCAD.Vector(1,0,0)
#        pt = FreeCAD.Vector(0, face.BoundBox.YMin - fp.DiameterTweak, 0)
#        revolve = face.revolve(pt,direction,180)
#        revolve = revolve.fuse(revolve.mirror(pt,FreeCAD.Vector(0,0,1)))
#        revolve.Placement.move(pt*-1) #centers at pt, axis of rotation
#        revolve.transformShape(revolve.Placement.toMatrix(),True)
#        revolve.Placement = FreeCAD.Placement()
#        #at this point the object is oriented horizontally and centered on the origin
#        #will be rotated vertically in a later step
#        wid = revolve.BoundBox.XLength #overall height, once rotated
#        ht = revolve.BoundBox.ZLength
#        length = revolve.BoundBox.YLength
#        btPos = wid * fp.SlotBottom #bottom position of slots to be cut
#        #fp.SlotAngle will be angle of slots
#        #fp.SlotCount will be number of slots to cut
#        centerEdge = Part.makeLine(FreeCAD.Vector(btPos,0,0),FreeCAD.Vector(btPos,length,0))
#        topEdge = Part.makeLine(FreeCAD.Vector(btPos,length,0),FreeCAD.Vector(wid,length,0))
#        rightEdge = Part.makeLine(FreeCAD.Vector(wid,length,0),FreeCAD.Vector(wid,0,0))
#        bottomEdge = Part.makeLine(FreeCAD.Vector(wid,0,0),FreeCAD.Vector(btPos,0,0))
#        wire = Part.Wire([centerEdge,topEdge,rightEdge,bottomEdge])
#        face = Part.makeFace(wire,"Part::FaceMakerCheese")
#        slotTool = face.revolve(centerEdge.Vertex1.Point,FreeCAD.Vector(1,0,0),fp.SlotAngle)
#        slotTool = slotTool.makeFillet(fp.SlotToolFilletRadius,[slotTool.Edge2,slotTool.Edge3])
#        toolCopies = Part.Shape()
#        for ii in range(0,fp.SlotCount):
#            copy = slotTool.copy()
#            copy.rotate(centerEdge.Vertex1.Point,FreeCAD.Vector(1,0,0), ii * (360 / fp.SlotCount))
#            if toolCopies.isNull():
#                toolCopies = copy
#            else:
#                toolCopies = toolCopies.fuse(copy)
#        if not toolCopies.isNull():
#            revolve = revolve.cut(toolCopies)
#        mirror = revolve.mirror(FreeCAD.Vector(0,0,0),FreeCAD.Vector(-1,0,0))
#        if fp.Symmetric:
#            revolve = revolve.fuse(mirror)
#        elif fp.Reversed:
#            revolve = mirror
#        cog = mirror.Face1.CenterOfGravity
#        revolve.Placement.rotate(FreeCAD.Vector(0,0,0),FreeCAD.Vector(0,1,0),90)
#        revolve = revolve.transformShape(revolve.Placement.toMatrix(),True)
#        revolve.Placement = FreeCAD.Placement()
#        revolve.rotate(cog,FreeCAD.Vector(0,0,1),fp.Angle)
#        revolve = revolve.transformShape(revolve.Placement.toMatrix(),True)
#        revolve.Placement = FreeCAD.Placement()
#        revolve.rotate(cog,FreeCAD.Vector(0,1,0),fp.AngleY)
#        revolve = revolve.transformShape(revolve.Placement.toMatrix(),True)
#        revolve.Placement = FreeCAD.Placement()
#        revolve.rotate(cog,FreeCAD.Vector(1,0,0),fp.AngleX)
#        revolve = revolve.transformShape(revolve.Placement.toMatrix(),True)
#        revolve.Placement = FreeCAD.Placement()
#        revolve.Placement.move(fp.Position)
#        revolve = revolve.transformShape(revolve.Placement.toMatrix(),True)
#        revolve.Placement = FreeCAD.Placement()
#        return revolve
#
#    def makeCantileverHook(self,fp):
#        face = self.makeCantileverHookFace(fp)
#        face.Placement.move(fp.Position)
#        direction = FreeCAD.Vector(0,0,1)
#        extrude = face.extrude(direction*fp.Width)
#        if fp.Symmetric or fp.Reversed:
#            mirror = extrude.mirror(FreeCAD.Vector(0,0,0),FreeCAD.Vector(-1,0,0))
#        if fp.Symmetric:
#            extrude = extrude.fuse(mirror)
#        elif fp.Reversed:
#            extrude = mirror
#        extrude.Placement.rotate(FreeCAD.Vector(0,0,0),FreeCAD.Vector(-1,-1,-1),120)
#        extrude.Placement.move(FreeCAD.Vector(0,-fp.Width/2,0))
#        extrude = extrude.transformShape(extrude.Placement.toMatrix(),True)
#        extrude.Placement = FreeCAD.Placement()
#        extrude.Placement.rotate(FreeCAD.Vector(0,0,0),FreeCAD.Vector(0,0,1),180)
#        extrude = extrude.transformShape(extrude.Placement.toMatrix(),True)
#        extrude.Placement = FreeCAD.Placement()
#        if not fp.Symmetric:
#            cog = extrude.Face1.CenterOfGravity
#        else:
#            cog = extrude.Vertex2.Point.add(extrude.Vertex9.Point)/2
#        extrude.rotate(cog,FreeCAD.Vector(0,0,1),fp.Angle)
#        extrude = extrude.transformShape(extrude.Placement.toMatrix(),True)
#        extrude.rotate(cog,FreeCAD.Vector(0,1,0),fp.AngleY)
#        extrude = extrude.transformShape(extrude.Placement.toMatrix(),True)
#        extrude.rotate(cog,FreeCAD.Vector(1,0,0),fp.AngleX)
#        extrude = extrude.transformShape(extrude.Placement.toMatrix(),True)
#        return extrude
#
#    def makeAnnularMate(self,fp):
#        face = self.makeCantileverMateFace(fp,True)
#        direction = FreeCAD.Vector(1,0,0)
#        pt = FreeCAD.Vector(0,face.BoundBox.YMin, 0)
#        revolve = face.revolve(pt,direction,180)
#        revolve = revolve.fuse(revolve.mirror(pt,FreeCAD.Vector(0,0,1)))
#        revolve.Placement.move(pt*-1) #centers at pt, axis of rotation
#        revolve.transformShape(revolve.Placement.toMatrix(),True)
#        revolve.Placement = FreeCAD.Placement()
#        #at this point the object is oriented horizontally and centered on the origin
#        #will be rotated vertically in a later step
#        mirror = revolve.mirror(FreeCAD.Vector(0,0,0),FreeCAD.Vector(-1,0,0))
#        if fp.Symmetric:
#            revolve = revolve.fuse(mirror)
#        elif fp.Reversed:
#            revolve = mirror
#        cog = mirror.Face1.CenterOfGravity
#        revolve.Placement.rotate(FreeCAD.Vector(0,0,0),FreeCAD.Vector(0,1,0),90)
#        revolve = revolve.transformShape(revolve.Placement.toMatrix(),True)
#        revolve.Placement = FreeCAD.Placement()
#        revolve.rotate(cog,FreeCAD.Vector(0,0,1),fp.Angle)
#        revolve = revolve.transformShape(revolve.Placement.toMatrix(),True)
#        revolve.Placement = FreeCAD.Placement()
#        revolve.rotate(cog,FreeCAD.Vector(0,1,0),fp.AngleY)
#        revolve = revolve.transformShape(revolve.Placement.toMatrix(),True)
#        revolve.Placement = FreeCAD.Placement()
#        revolve.rotate(cog,FreeCAD.Vector(1,0,0),fp.AngleX)
#        revolve = revolve.transformShape(revolve.Placement.toMatrix(),True)
#        revolve.Placement = FreeCAD.Placement()
#        revolve.Placement.move(fp.Position)
#        revolve = revolve.transformShape(revolve.Placement.toMatrix(),True)
#        revolve.Placement = FreeCAD.Placement()
#        return revolve
#
#    def makeCantileverMateFace(self,fp, annular=False):
#        ##cantilever hook calculations first, then we'll use them as references for the
#        ##mate cutting tool shape, offset by fp.CantileverMateClearance (default 0.5mm)
#
#        length = fp.Length #h in diagram
#        depth = fp.Depth #length in diagram
#        angle = fp.NoseAngle
#        radius = fp.RadiusFactor * length #default = 0.6 * length
#        undercut = fp.ShapeDeflection * fp.MaterialDeflection * depth * depth / length
#        fp.Undercut = undercut
#        baseline = length + radius + radius #bottom of bottom fillet to top of top fillet
#        upt = fp.UndercutPositionTweak
#        uat = math.tan(math.radians(fp.UndercutAngle))*undercut #undercut angle tweak
#        ## Points
#        filletCenterBottom = FreeCAD.Vector(radius, -baseline/2, 0)
#        filletCenterTop = FreeCAD.Vector(radius, baseline/2, 0)
#        baselineBottom = FreeCAD.Vector(0, -baseline/2, 0)
#        baselineTop = FreeCAD.Vector(0, baseline/2, 0)
#        undercutBottom = FreeCAD.Vector(upt + uat + radius + depth, length/2, 0)
#        undercutTop = FreeCAD.Vector(upt + radius + depth, length/2 + undercut, 0)
#        undercutRight = FreeCAD.Vector(radius + depth + undercut, length/2 + undercut, 0)
#        noseBottom = FreeCAD.Vector(radius + depth + undercut + math.tan(math.radians(angle))*undercut, 0, 0)
#        noseTop = FreeCAD.Vector(radius + depth + undercut + math.tan(math.radians(angle))*undercut, length/2, 0)
#        topArc = Part.makeCircle(radius,filletCenterTop,FreeCAD.Vector(0,0,1),180,270)
#
#        ## now for the mate points
#        offset = fp.CantileverMateClearance
#        baselineTop2 = baselineTop.add(FreeCAD.Vector(0,offset,0))
#        topArcPt2 = topArc.Vertex2.Point.add(FreeCAD.Vector(0,offset,0))
#        undercutBottom2 = undercutBottom.add(FreeCAD.Vector(-offset,offset,0))
#        undercutTop2 = undercutTop.add(FreeCAD.Vector(-offset,offset,0))
#        topRight = FreeCAD.Vector(noseTop.x + undercut + fp.HeadSpaceAdjust, undercutTop.y + offset,0)
#        if not annular:
#            bottomRight = FreeCAD.Vector(topRight.x, -topRight.y - offset, 0)
#            baselineBottom2 = FreeCAD.Vector(0, -topRight.y -offset, 0)
#        else:
#            bottomRight = FreeCAD.Vector(topRight.x, -topRight.y + length/10 - fp.DiameterTweak, 0)
#            baselineBottom2 = FreeCAD.Vector(0, -topRight.y + length/10 - fp.DiameterTweak, 0)
#
#        ## Edges
#        baseline2 = Part.makeLine(baselineBottom2, baselineTop2)
#        leftSlant = Part.makeLine(baselineTop2, topArcPt2)
#        topLine = Part.makeLine(topArcPt2, undercutBottom2)
#        undercutLeft2 = Part.makeLine(undercutBottom2, undercutTop2)
#        topRightLine2 = Part.makeLine(undercutTop2, topRight)
#        rightLine = Part.makeLine(topRight, bottomRight)
#        bottomLine2 = Part.makeLine(bottomRight, baselineBottom2)
#        wire = Part.Wire([baseline2, leftSlant, topLine, undercutLeft2, topRightLine2, rightLine, bottomLine2])
#        face = Part.makeFace(wire,"Part::FaceMakerCheese")
#        if not annular:
#            face.Placement.move(FreeCAD.Vector(0,0,-offset))
#        return face
#
#    def makeCantileverMate(self,fp):
#        face = self.makeCantileverMateFace(fp)
#        face.Placement.move(fp.Position)
#        direction = FreeCAD.Vector(0,0,1)
#        offset = fp.CantileverMateClearance
#        extrude = face.extrude(direction*(fp.Width + 2*offset))
#        if fp.Symmetric or fp.Reversed:
#            mirror = extrude.mirror(FreeCAD.Vector(0,0,0),FreeCAD.Vector(-1,0,0))
#        if fp.Symmetric:
#            extrude = extrude.fuse(mirror)
#        elif fp.Reversed:
#            extrude = mirror
#        extrude.Placement.rotate(FreeCAD.Vector(0,0,0),FreeCAD.Vector(-1,-1,-1),120)
#        extrude.Placement.move(FreeCAD.Vector(0,-fp.Width/2,0))
#        extrude = extrude.transformShape(extrude.Placement.toMatrix(),True)
#        extrude.Placement = FreeCAD.Placement()
#        extrude.Placement.rotate(FreeCAD.Vector(0,0,0),FreeCAD.Vector(0,0,1),180)
#        extrude = extrude.transformShape(extrude.Placement.toMatrix(),True)
#        extrude.Placement = FreeCAD.Placement()
#        extrude.rotate(extrude.Face1.CenterOfGravity,FreeCAD.Vector(0,0,1),fp.Angle)
#        extrude = extrude.transformShape(extrude.Placement.toMatrix(),True)
#        extrude.rotate(extrude.Face1.CenterOfGravity,FreeCAD.Vector(0,1,0),fp.AngleY)
#        extrude = extrude.transformShape(extrude.Placement.toMatrix(),True)
#        extrude.rotate(extrude.Face1.CenterOfGravity,FreeCAD.Vector(1,0,0),fp.AngleX)
#        extrude = extrude.transformShape(extrude.Placement.toMatrix(),True)
#        return extrude
#
#    def makeMortiseTenon(self,fp):
#        '''make the shape'''
#        adjust = fp.Position
#        topLeft = FreeCAD.Vector(-fp.Width/2,fp.Length/2,0).add(adjust)
#        topRight = FreeCAD.Vector(fp.Width/2,fp.Length/2,0).add(adjust)
#        bottomLeft = FreeCAD.Vector(-fp.Width/2,-fp.Length/2,0).add(adjust)
#        bottomRight = FreeCAD.Vector(fp.Width/2,-fp.Length/2,0).add(adjust)
#        midLeft = FreeCAD.Vector(-fp.Width/2,0,0).add(adjust)
#        midRight = FreeCAD.Vector(fp.Width/2,0,0).add(adjust)
#        top = Part.makeLine(topLeft,topRight)
#        bottom = Part.makeLine(bottomLeft,bottomRight)
#        left = Part.makeCircle(fp.Length/2,midLeft,FreeCAD.Vector(0,0,1),90,270)
#        right = Part.makeCircle(fp.Length/2,midRight,FreeCAD.Vector(0,0,1),270,90)
#        wire = Part.Wire([top,right,bottom,left])
#        wire.rotate(FreeCAD.Vector(0,0,0),FreeCAD.Vector(0,0,1),fp.Angle)
#        face = Part.makeFace(wire,"Part::FaceMakerCheese")
#        if fp.Offset != 0:
#            face = face.makeOffset2D(fp.Offset)
#        if fp.Reversed:
#            direction = FreeCAD.Vector(0,0,-1)
#        else:
#            direction = FreeCAD.Vector(0,0,1)
#        if fp.JointType == "Mortise":
#            direction = direction * (-1)
#        extrude = face.extrude(direction*fp.Depth)
#        if fp.Symmetric:
#            extrude2 = face.extrude(direction*-1*fp.Depth)
#            extrude = extrude.fuse(extrude2)
#        extrude.rotate(FreeCAD.Vector(0,0,0),FreeCAD.Vector(0,1,0),fp.AngleY)
#        extrude = extrude.transformShape(extrude.Placement.toMatrix(),True)
#        extrude.rotate(FreeCAD.Vector(0,0,0),FreeCAD.Vector(1,0,0),fp.AngleX)
#        extrude = extrude.transformShape(extrude.Placement.toMatrix(),True)
#        return extrude
#
#class TaskEditLinkSubPanel: #simple editor for App::PropertyLinkSub
#    def __init__(self, obj, linkSubName, subNames,):
#        self.obj = obj
#        self.subNames = subNames
#        self.linkSubName = linkSubName #entire LinkSub property
#        self.linkObj = getattr(self.obj,linkSubName)[0]
#        self.subObjects = getattr(self.obj,linkSubName)[1]
#        self.form = QtGui.QWidget()
#        self.label1 = QtGui.QLabel("Select the "+self.subNames+" subobjects to use and click OK.\nThe ones already being utilized have been selected for you.")
#        layout=QtGui.QHBoxLayout()
#        layout.addWidget(self.label1)
#        self.form.setLayout(layout)
#        self.form.setWindowTitle('Edit '+self.subNames)
#        self.obj.ViewObject.Visibility = False
#        self.linkObj.ViewObject.Visibility = True
#        FreeCADGui.Selection.clearSelection()
#        for f in self.subObjects:
#            FreeCADGui.Selection.addSelection(FreeCAD.ActiveDocument.Name,self.linkObj.Name,f)
#        self.obj.Proxy.editingMode = True
#
#    def reject(self):
#        FreeCADGui.Control.closeDialog()
#        fp = self.obj
#        self.linkObj.ViewObject.Visibility = False
#        fp.ViewObject.Visibility = True
#        self.obj.Proxy.editingMode = False #self.obj.Proxy is the Joint class object (self in that class)
#        FreeCADGui.activeDocument().resetEdit()
#        FreeCAD.ActiveDocument.recompute()
#
#    def accept(self):
#        FreeCADGui.ActiveDocument.resetEdit()
#        FreeCADGui.Control.closeDialog()
#        fp = self.obj
#        if not fp: #user deleted or closed document perhaps
#            return
#        selx = FreeCADGui.Selection.getSelectionEx()
#        if not selx:
#            FreeCAD.Console.PrintWarning("Nothing selected, leaving "+self.linkObj.Name+" unmodified.")
#            return
#        seNames = [sen for sen in selx[0].SubElementNames]
#        setattr(self.obj,self.linkSubName,(selx[0].Object,seNames)) #allow user to select diffent object
#        self.linkObj = selx[0].Object
#        if hasattr(fp,"_Body") and fp._Body and self.linkObj not in fp._Body.Group:
#            fp._Body.Group += [self.linkObj]
#            if not self.linkObj.isDerivedFrom("PartDesign::Feature"):
#               fp.ClaimChildren = True
#        self.linkObj.ViewObject.Visibility = False
#        fp.ViewObject.Visibility = True
#        if hasattr(fp.Proxy,"editingMode"):
#            fp.Proxy.editingMode = False
#        FreeCAD.ActiveDocument.recompute()
#
#
#class JointVP:
#
#    def __init__(self, obj):
#        '''Set this object to the proxy object of the actual view provider'''
#        obj.Proxy = self
#
#    def attach(self, obj):
#        '''Setup the scene sub-graph of the view provider, this method is mandatory'''
#        self.Object = obj.Object
#
#    def updateData(self, fp, prop):
#        '''If a property of the handled feature has changed we have the chance to handle this here'''
#        # fp is the handled feature, prop is the name of the property that has changed
#        pass
#
#    def getDisplayModes(self,obj):
#        '''Return a list of display modes.'''
#        modes=[]
#        modes.append("Flat Lines")
#        return modes
#
#    def setEdit(self,vobj,modNum):
#        if modNum == 0:
#            vobj.Object.Proxy.editFace()
#            return True
#        elif modNum == 3:
#            FreeCADGui.runCommand('Part_ColorPerFace',0)
#            return True
#
#    def getDefaultDisplayMode(self):
#        '''Return the name of the default display mode. It must be defined in getDisplayModes.'''
#        return "Flat Lines"
 
#    def setDisplayMode(self,mode):
#        '''Map the display mode defined in attach with those defined in getDisplayModes.\
#                Since they have the same names nothing needs to be done. This method is optional'''
#        return mode
#
#    def onChanged(self, vp, prop):
#        '''Here we can do something when a single property got changed'''
#        #FreeCAD.Console.PrintMessage("Change property: " + str(prop) + ""+chr(10))
#
#    def claimChildren(self):
#        if self.Object.ClaimChildren and self.Object.Face and not self.Object.Shape.isNull() and self.Object.Boolean:
#            return [self.Object.Face[0]]
#        else:
#            return []
#
#    def onDelete(self, vobj, subelements):
#        if vobj.Object.Face:
#            vobj.Object.Face[0].ViewObject.Visibility = True
#        if hasattr(vobj.Object,"_Body"): #do this only when the object is in a PD body
#            #need to ensure the next feature in the tree's BaseFeature property points to our BaseFeature
#            solids = [feat for feat in vobj.Object._Body.Group if feat.isDerivedFrom("PartDesign::Feature") and feat.BaseFeature == vobj.Object]
#            if len(solids) == 1: #found previous solid feature
#                solids[0].BaseFeature = vobj.Object.BaseFeature
#        return True
#
#    def getIcon(self):
#        '''Return the icon in XPM format which will appear in the tree view. This method is\
#                optional and if not defined a default icon is shown.'''
#        return '''
#/* XPM */
#static char *Macro_Joint_Icon[] = {
#/* columns rows colors chars-per-pixel */
#"64 64 175 2 ",
#"   c #030204",
#".  c #0A0202",
#"X  c #040609",
#"o  c #080608",
#"O  c #06090D",
#"+  c #0F0B0F",
#"@  c #150303",
#"#  c #1C0404",
#"$  c #1D0708",
#"%  c #1C090A",
#"&  c #070C12",
#"*  c #090F16",
#"=  c #130E14",
#"-  c #0B1017",
#";  c #0C131C",
#":  c #14161E",
#">  c #230404",
#",  c #2B0505",
#"<  c #220809",
#"1  c #290C0C",
#"2  c #330404",
#"3  c #340E0E",
#"4  c #3A0C0C",
#"5  c #3B0303",
#"6  c #2F1011",
#"7  c #3E1313",
#"8  c #0E1721",
#"9  c #0F1924",
#"0  c #0F1A28",
#"q  c #121A25",
#"w  c #1A1A23",
#"e  c #121D2A",
#"r  c #1C1F2F",
#"t  c #1C232F",
#"y  c #152334",
#"u  c #192534",
#"i  c #1C2837",
#"p  c #162639",
#"a  c #182638",
#"s  c #17293D",
#"d  c #1A2A3D",
#"f  c #252C3B",
#"g  c #420404",
#"h  c #4A0505",
#"j  c #410909",
#"k  c #4A0909",
#"l  c #530404",
#"z  c #540B0B",
#"x  c #5A0A0A",
#"c  c #5E0505",
#"v  c #471717",
#"b  c #4B1415",
#"n  c #541616",
#"m  c #5C1414",
#"M  c #561B1B",
#"N  c #5A1D1D",
#"B  c #640606",
#"V  c #6D0606",
#"C  c #620F0F",
#"Z  c #6C0B0B",
#"A  c #750606",
#"S  c #790606",
#"D  c #740A0A",
#"F  c #7D0909",
#"G  c #651313",
#"H  c #661B1B",
#"J  c #771212",
#"K  c #791010",
#"L  c #751C1C",
#"P  c #672020",
#"I  c #762222",
#"U  c #7B2020",
#"Y  c #1A2D44",
#"T  c #1B2F48",
#"R  c #1E3046",
#"E  c #1E334C",
#"W  c #1F3551",
#"Q  c #232D42",
#"!  c #233246",
#"~  c #26364A",
#"^  c #2A3649",
#"/  c #2F394A",
#"(  c #313B4B",
#")  c #203752",
#"_  c #213955",
#"`  c #2B3E55",
#"'  c #253D5B",
#"]  c #293F5A",
#"[  c #2C4057",
#"{  c #27405F",
#"}  c #2B415C",
#"|  c #304154",
#" . c #31445B",
#".. c #274467",
#"X. c #2B4462",
#"o. c #2F4867",
#"O. c #29476C",
#"+. c #334A67",
#"@. c #364F6C",
#"#. c #324763",
#"$. c #2D4E78",
#"%. c #2B4B72",
#"&. c #2E5079",
#"*. c #385170",
#"=. c #3D5A7E",
#"-. c #465D77",
#";. c #810707",
#":. c #8A0707",
#">. c #820D0D",
#",. c #940808",
#"<. c #9F0808",
#"1. c #851010",
#"2. c #891313",
#"3. c #811C1C",
#"4. c #981A1A",
#"5. c #A70909",
#"6. c #AA0909",
#"7. c #B30909",
#"8. c #BE0A0A",
#"9. c #A01313",
#"0. c #B61818",
#"q. c #872727",
#"w. c #9C2626",
#"e. c #912828",
#"r. c #AE2C2C",
#"t. c #A72323",
#"y. c #BF2A2A",
#"u. c #B52626",
#"i. c #A73232",
#"p. c #BE3434",
#"a. c #BB3B3B",
#"s. c #C10A0A",
#"d. c #C41313",
#"f. c #C61B1B",
#"g. c #C62121",
#"h. c #C92424",
#"j. c #CB2C2C",
#"k. c #CE3333",
#"l. c #CF3838",
#"z. c #D03C3C",
#"x. c #CD4040",
#"c. c #C64242",
#"v. c #D14141",
#"b. c #325682",
#"n. c #365986",
#"m. c #355B8A",
#"M. c #3E5B82",
#"N. c #375F90",
#"B. c #3A6295",
#"V. c #3B659A",
#"C. c #3D689F",
#"Z. c #3E6BA3",
#"A. c #466386",
#"S. c #406390",
#"D. c #4B6C93",
#"F. c #4F739E",
#"G. c #54749D",
#"H. c #59789E",
#"J. c #426EA5",
#"K. c #4571A7",
#"L. c #4C72A1",
#"P. c #4772A8",
#"I. c #4A75AA",
#"U. c #4E78AC",
#"Y. c #527BAE",
#"T. c #597DAA",
#"R. c #5277A3",
#"E. c #567FB0",
#"W. c #5B82B3",
#"Q. c #6087B6",
#"!. c #6388B6",
#"~. c #668BB9",
#"^. c #698EBB",
#"/. c #6D91BD",
#"(. c None",
#/* pixels */
#"(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.",
#"(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.",
#"(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.",
#"(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.",
#"(.(.(.(.(.(.(.(.(.(.F > . (.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.  - ' (.(.(.(.(.(.(.(.(.(.",
#"(.(.(.(.(.(.(.(.F F F >.x . . (.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.X X p ' W W W (.(.(.(.(.(.(.(.",
#"(.(.(.(.(.(.S S S F F F >.F k     (.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.    e ' ' W W W { ' W (.(.(.(.(.(.",
#"(.(.(., g A S S S S F F F >.>.D 2   (.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.X ; E ' ' W W ' W W W W W y 0 (.(.(.",
#"(.(.(.t.7 . l A S S S F F F >.>.>.Z #   (.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.X O R ' ' { { W _ ) _ _ W T O e M.(.(.(.",
#"(.(.(.k.k.w.$ > B S S F S F F >.>.>.>.x . . (.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.X X u { ' ' W W W W _ _ _ T 8 * =.Y.Y.(.(.(.",
#"(.(.(.j.j.k.k.U . , V S S F F F >.>.>.>.>.j     (.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.  q ' { ' ' ' ' W W ' _ E e X { Y.Y.Y.Y.(.(.(.",
#"(.(.(.j.j.j.j.k.j.n . g S S S F F >.>.>.1.1.F , . (.(.(.(.(.(.(.(.(.(.(.(.(.(.  ; _ { ' { ' _ _ ' W W W u X d R.E.E.Y.Y.Y.(.(.(.",
#"(.(.(.j.j.j.j.k.k.l.r.3 @ l F F F F >.>.>.1.1.2.C @ . (.(.(.(.(.(.(.(.(.(.  X R { { { ' ' _ _ _ W W Y & e D.Y.E.E.Y.Y.Y.U.(.(.(.",
#"(.(.(.h.j.j.j.k.k.k.l.l.e.@ > V F F F >.>.>.1.1.2.2.z . . (.(.(.(.(.(.  X i X.X.{ { ' ' ' _ _ E W 0 O &.E.Y.E.Y.Y.Y.I.Y.U.(.(.(.",
#"(.(.(.h.h.j.j.j.j.k.k.k.l.l.L . 2 D F F >.>.>.1.1.1.2.1.j .   (.(.(.  q ] X.{ { } ' ' ' _ _ ) y X _ Y.W.E.E.E.Y.Y.I.U.I.I.(.(.(.",
#"(.(.(.h.h.h.j.j.j.j.k.k.l.l.l.a.n . h F F F >.1.1.1.2.2.2.J > .   - _ X.X.X.{ ' ' ' _ _ _ p O a F.W.W.W.E.E.Y.Y.Y.U.I.I.U.(.(.(.",
#"(.(.(.h.h.h.h.j.j.j.j.k.k.k.k.z.z.i.1 # c F >.>.>.1.1.2.2.K < X R o.X.X.{ { { { _ { W Y * ; N.W.W.W.W.Y.W.U.U.Y.U.U.I.I.I.(.(.(.",
#"(.(.(.f.g.h.h.h.j.j.j.j.k.k.l.z.z.z.x.e.@ , D F >.1.>.K 4 . a } o.X.X.} } { ' ' _ E 9 O @.W.W.W.W.Y.Y.Y.Y.Y.U.U.U.I.I.I.P.(.(.(.",
#"(.(.(.f.f.h.h.h.h.j.j.j.k.k.k.k.k.z.z.z.l.P . 4 D >.z . q } o.o.X.} { { { ' ' _ y X ^ W.W.W.W.W.W.Y.W.U.Y.U.U.U.I.I.I.P.P.(.(.(.",
#"(.(.(.f.f.f.h.h.h.h.j.j.j.j.k.k.k.z.z.z.x.v.a.v . . - ` o.o.o.} X.X.} { { _ i O u G.W.W.W.W.Y.W.Y.W.Y.U.U.U.U.I.I.I.P.P.K.(.(.(.",
#"(.(.(.d.f.f.f.h.h.h.h.j.j.j.k.j.k.k.z.z.z.z.v.v.N O : _ +.X.X.{ X.{ ' ' E - - A.W.!.W.W.W.W.Y.W.Y.Y.W.U.I.I.U.I.I.P.K.K.K.(.(.(.",
#"(.(.(.f.f.f.f.f.h.h.h.h.j.j.j.k.k.k.l.k.z.z.v.v.I ( -.O q ] X.{ { { W 0 O @.!.W.W.W.W.W.W.Y.Y.Y.W.U.U.U.U.I.I.P.P.K.K.K.K.(.(.(.",
#"(.(.(.d.d.f.f.f.f.h.h.h.h.j.j.j.j.k.k.k.l.z.z.z.I ( /.!.| X y ] { y X ~ T.W.W.W.W.W.W.W.Y.W.W.Y.U.U.U.U.I.I.I.I.P.K.K.J.J.(.(.(.",
#"(.(.(.d.d.d.f.f.f.f.h.h.h.h.h.j.j.j.k.k.l.l.z.z.U ( /././.H.u O O t G.!.!.!.W.W.W.W.Y.W.W.Y.U.Y.U.U.U.I.I.I.P.P.K.K.K.K.Z.(.(.(.",
#"(.(.(.d.d.d.f.f.f.f.f.h.h.h.h.j.j.j.j.k.k.k.l.z.U ( ^.^.^.^.~.^ ~ !.!.W.!.W.W.W.E.W.Y.E.Y.Y.Y.Y.U.U.U.I.I.P.P.K.K.K.K.Z.Z.(.(.(.",
#"(.(.(.s.s.d.d.d.d.f.f.g.f.h.h.j.j.j.j.j.k.k.k.z.I ( ^.^.^.~.~. . .!.!.!.W.W.W.W.W.W.E.Y.Y.Y.U.U.U.U.I.I.P.P.K.K.K.Z.Z.Z.Z.(.(.(.",
#"(.(.(.s.d.d.d.d.f.d.f.f.h.h.h.h.h.j.j.j.j.k.k.k.L ( ^.^.~.~.~. . .!.!.W.W.W.W.W.W.Y.U.W.Y.Y.U.U.I.P.I.P.P.P.Z.K.J.K.Z.Z.Z.(.(.(.",
#"(.(.(.s.s.s.s.d.d.f.d.f.f.f.f.h.h.h.j.j.j.k.k.k.L / ^.^.~.~.!. .[ W.W.W.W.W.W.W.Y.W.Y.Y.U.U.U.U.U.I.P.P.K.K.K.K.Z.Z.Z.Z.Z.(.(.(.",
#"(.(.(.s.s.s.d.d.d.d.d.f.f.f.h.h.h.h.h.j.j.j.j.k.L / ~.~.~.!.!. .[ W.W.W.W.W.U.W.W.U.Y.U.U.U.U.I.P.P.P.P.K.K.Z.K.Z.Z.Z.Z.Z.(.(.(.",
#"(.(.(.s.s.s.s.s.s.d.d.f.d.f.f.f.h.h.h.j.j.j.j.j.L / ~.~.!.!.Q. .} W.W.W.W.W.=.o.U.W.U.U.U.U.I.I.P.P.P.K.Z.K.Z.Z.Z.Z.Z.Z.Z.(.(.(.",
#"(.(.(.s.s.s.s.s.s.d.d.d.d.f.f.f.f.g.h.h.h.j.j.j.L / !.!.!.!.Q.} [ W.W.W.W.o.  o.U.U.U.U.U.P.P.I.K.K.K.K.K.Z.Z.Z.Z.Z.Z.Z.Z.(.(.(.",
#"(.(.(.s.s.s.s.s.s.d.s.d.d.f.d.f.f.h.f.h.h.h.j.j.L f !.!.Q.W.W. .[ W.W.W.~ % 7 } U.U.U.U.U.P.I.P.K.K.K.Z.K.Z.Z.Z.Z.Z.Z.Z.Z.(.(.(.",
#"(.(.(.s.s.s.s.s.s.s.s.d.d.d.d.f.f.f.f.h.h.h.h.j.t.% w D.Q.W.W. .} W.T.t 6 c.N X.U.I.U.I.I.I.K.K.K.J.J.J.Z.Z.Z.Z.Z.Z.Z.Z.Z.(.(.(.",
#"(.(.(.s.s.s.s.s.s.s.s.d.d.d.d.d.f.f.f.f.h.h.h.h.j.j.3.. f T.W.` [ R.: v x.v.N X.Y.I.I.I.I.I.K.K.K.J.J.J.Z.Z.Z.Z.Z.Z.Z.Z.Z.(.(.(.",
#"(.(.(.s.s.s.s.s.s.s.s.s.s.d.d.d.d.f.f.f.f.h.h.h.h.j.j.j.m o ` ` ~ + P v.v.v.N X.I.I.I.I.K.K.K.K.J.J.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.(.(.(.",
#"(.(.(.s.s.s.s.s.s.s.s.s.s.s.s.d.d.d.f.f.f.f.g.h.h.h.j.h.j.r.3 .   U z.z.v.v.M X.I.I.I.P.K.K.K.J.J.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.(.(.(.",
#"(.(.(.s.s.s.s.s.s.s.s.s.s.s.s.s.d.d.d.f.f.f.f.h.h.h.h.j.j.k.j.b b l.l.z.l.v.M } I.P.P.P.J.J.J.J.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.(.(.(.",
#"(.(.(.s.s.s.s.s.s.s.s.s.s.s.s.s.d.d.d.d.f.f.f.f.g.h.h.h.h.j.j.H G k.k.l.z.z.M X.I.P.P.K.J.J.J.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.(.(.(.",
#"(.(.(.s.s.s.s.s.s.s.s.s.s.s.s.s.s.d.d.d.d.f.f.f.f.h.h.h.h.j.j.G G k.k.k.l.l.M X.P.P.J.J.J.J.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.(.(.(.",
#"(.(.(.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.d.d.d.d.f.f.f.g.g.h.h.j.h.H H j.k.l.l.l.n { P.P.J.J.J.J.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.(.(.(.",
#"(.(.(.s.s.s.s.s.s.s.s.s.s.s.s.8.s.s.d.d.d.d.d.f.f.f.g.g.h.h.h.G G j.k.k.l.l.n X.K.J.J.J.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.(.(.(.",
#"(.(.(.s.s.s.s.s.s.8.s.s.s.s.s.s.s.s.s.s.s.d.d.d.f.f.f.g.g.h.h.G G j.j.j.j.l.n { K.J.J.J.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.(.(.(.",
#"(.(.(.s.s.8.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.d.d.d.d.d.f.f.f.h.h.G G j.j.j.k.j.n { J.J.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.(.(.(.",
#"(.(.(.2 B 8.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.d.d.1.2.d.d.f.g.g.Z C h.j.j.j.j.n ' J.J.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.W e (.(.(.",
#"(.(.(.(.. @ ;.s.s.s.s.s.s.s.s.s.s.s.s.s.s.s.d.d.D   , 4.f.f.g.C C h.j.j.j.j.n ' Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.$.* O (.(.(.(.",
#"(.(.(.(.(.(.. , <.8.s.s.s.s.s.s.s.s.s.s.s.s.s.s.D Q o.o k 0.f.G C h.h.h.h.u.4 ' Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.m.e X (.(.(.(.(.(.",
#"(.(.(.(.(.(.(.(.. h 7.s.s.s.s.s.s.s.s.s.s.s.s.s.V Q U.L.Q . D C C g.4.m % . u b.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.B.E X (.(.(.(.(.(.(.(.",
#"(.(.(.(.(.(.(.(.(.. . V 8.s.s.s.s.s.s.s.s.s.s.s.Z Q U.U.I.S.w . > . = ~ b.Z.J.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z...X X (.(.(.(.(.(.(.(.(.",
#"(.(.(.(.(.(.(.(.(.(.(.. # :.s.s.s.s.s.s.s.s.s.s.V Q I.I.U.P.P.d u V.J.J.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.$.* X (.(.(.(.(.(.(.(.(.(.(.",
#"(.(.(.(.(.(.(.(.(.(.(.(.(.. 2 5.s.s.s.s.s.s.s.s.V f I.I.P.I.P.) _ J.J.J.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.m.p X (.(.(.(.(.(.(.(.(.(.(.(.(.",
#"(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.  l 7.s.s.s.s.s.s.A Q I.I.P.P.J._ ) J.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.V.W X   (.(.(.(.(.(.(.(.(.(.(.(.(.(.",
#"(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.. . A 8.s.s.s.s.V Q I.I.P.P.J.) ) J.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.O.& X (.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.",
#"(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.. > ,.s.s.s.V f P.P.K.K.J._ ) Z.Z.Z.Z.Z.Z.Z.Z.Z.Z.b.; X (.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.",
#"(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.. 5 6.s.V Q K.K.K.K.J.W W Z.Z.Z.Z.Z.Z.Z.Z.N.p X (.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.",
#"(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.  . c B Q K.K.J.J.J.W W Z.Z.Z.Z.Z.Z.Z.' X   (.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.",
#"(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.. . q J.K.J.J.Z.W W Z.Z.Z.Z.Z.O.& X (.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.",
#"(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.X 8 n.Z.Z.Z.W W Z.Z.Z.m.0 X (.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.",
#"(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.X p B.Z.W W Z.B.Y X (.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.",
#"(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.X X W E E ' X X (.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.",
#"(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.X X X X (.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.",
#"(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.",
#"(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.",
#"(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.",
#"(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(.(."
#};

#'''
 
#    def __getstate__(self):
#        '''When saving the document this object gets stored using Python's json module.\
#                Since we have some un-serializable parts here -- the Coin stuff -- we must define this method\
#                to return a tuple of all serializable objects or None.'''
#        return None
 
#    def __setstate__(self,state):
#        '''When restoring the serialized object from document we have the chance to set some internals here.\
#                Since no data were serialized nothing needs to be done here.'''
#        return None



############
#if __name__ == "__main__":
#    FreeCAD.Console.PrintMessage("Please run "+BASENAME+".FCMacro rather than this file.\n")
############

#CODE_ENDS_HERE

BASENAME = 'joint'

def getBody(feature):
    doc = FreeCAD.ActiveDocument
    bodies = [obj for obj in doc.Objects if obj.TypeId == "PartDesign::Body"]
    for bod in bodies:
        if feature in bod.Group:
            return bod
    return None

def getJointType():
    '''ask user the joint type to make, return as string'''
    from PySide import QtCore,QtGui
    window = QtGui.QApplication.activeWindow()
    items = ["Mortise","Tenon","Box Joint","Dovetail Joint","Cantilever Hook", "Cantilever Mate","Annular Hook","Annular Mate","Ball Joint","Ball Mate","Split Joint", "Split Mate","Cancel"]
    caption = "Select joint type"
    item,ok = QtGui.QInputDialog.getItem(window,"Joint type",caption,items,False)
    if ok:
        return item
    else:
        return None

def makeObject(FP):
    import DraftGeomUtils as DGU
    doc = FreeCAD.ActiveDocument
    body=None
    selobjs = FreeCADGui.Selection.getSelectionEx()
    if doc:
        doc.openTransaction("Create Joint")

        if selobjs:
            for selobj in selobjs:
                body = getBody(selobj.Object)
                jType = getJointType()
                if not jType:
                    continue
                if jType == "Tenon" or jType == "Cantilever Hook" or jType == "Annular Hook" or jType == "Ball Joint" or jType == "Split Joint":
                    orientation = "External"
                else:
                    orientation = "Internal"
                if body:
                    if orientation == "External":
                        joint = body.newObject("PartDesign::FeatureAdditivePython", "Joint")
                    else:
                        joint = body.newObject("PartDesign::FeatureSubtractivePython", "Joint")
                else:
                    joint = doc.addObject("Part::FeaturePython","Joint")
                FP.Joint(joint)
                FP.JointVP(joint.ViewObject)
                joint.AddSubType = "Additive" if bool(jType == "Tenon" or jType == "Cantilever Hook" or jType == "Annular Hook" or jType == "Ball Joint" or jType == "Split Joint") else "Subtractive"
                joint.Width = joint.Width * 10 if "Box" in jType or "Dovetail" in jType else joint.Width
                joint.Depth = 10 if "Split" in jType else joint.Depth
                joint.Proxy.execute(joint)
                if body:
                    joint.ClaimChildren = False #do not claim children in Part Design to preserve the linear tree
                if selobj.HasSubObjects:
                    faces = [name for name in selobj.SubElementNames if "Face" in name]
                    if faces and len(faces) == 1 and DGU.isPlanar(selobj.Object.getSubObject(faces[0])):
                        joint.Face = (selobj.Object,faces)
                    else:
                        FreeCAD.Console.PrintError("Select 1 (planar) face of an object. Using Face1\n")
                        joint.Face = (selobj.Object, ["Face1"])
                else:
                    joint.Face = (selobj.Object, ["Face1"])
                    FreeCAD.Console.PrintError("Select 1 (planar) face of an object.\n")
                joint.JointType = jType
                if "Cantilever" in jType or "Annular" in jType:
                    joint.Depth = 15
                    joint.Length = 3
        else:
            FreeCAD.Console.PrintMessage("No face selected to make a joint on.\n")

        doc.commitTransaction()
        doc.recompute()

def writeFile():
    with open(py_file,"w") as outfile:
        for line in code.splitlines():
            if "#CODE_ENDS_HERE" in line:
                break
            if line.startswith('#'):
                if line == "# -*- coding: utf-8 -*-":
                    line = "#" + line
                outfile.write(line[1:]+"\n") #skip first character (#)


if __name__ == "__main__":
    import os
    fin = open(__file__, 'r')
    code = fin.read()
    fin.close()
    version = code.splitlines()[1][16:]
    real_path = os.path.realpath(__file__)
    dir_path = os.path.dirname(real_path)
    py_file = real_path.replace(".FCMacro",".py").replace('Joint','joint')
    bHasFile = os.path.exists(py_file)
    noImport = False #user elects not to save import file

    if not bHasFile:
        from PySide import QtCore,QtGui
        window = QtGui.QApplication.activeWindow()
        items = ["Yes, go ahead and create the file.", "No, do not create the file.","Cancel"]
        caption = "In order for "+BASENAME+" objects to be parametric after saving and reloading file\n\
we need to create another file on this computer.  File to be created will be: \n\n"+py_file+"\n\n\
This makes it available to the system upon restarting FreeCAD and loading documents containing the \n\
"+BASENAME+" feature python objects.  May we proceed?\n\n"
        item,ok = QtGui.QInputDialog.getItem(window,"One time installation",caption,items)
        if ok and item == items[0]:
            writeFile()
            QtGui.QMessageBox.information(window,"Success","File successfully created.  Please note: if you uninstall "+BASENAME+" macro you need to manually remove this file, too.\n")
        else:
            new_lines = []
            for line in code.splitlines():
                if line.startswith('#'):
                    if "CODE_ENDS_HERE" in line:
                        break
                    if line == "# -*- coding: utf-8 -*-":
                        new_lines.append(line+"\n")
                        continue
                    new_lines.append(line[1:]+"\n")
            code = "".join(new_lines)

            #credit to Mila Nautikus for his answer to a question on stackoverflow, which I modified here
            #in this example the filename is bevel.py
            #https://stackoverflow.com/questions/5362771/how-to-load-a-module-from-code-in-a-string

            ##########
            import sys, importlib
            my_name = 'joint' #filename = joint.py, so this must be 'joint'
            my_spec = importlib.util.spec_from_loader(my_name, loader=None)

            joint = importlib.util.module_from_spec(my_spec)

            exec(code, joint.__dict__)
            sys.modules['joint'] = joint
            makeObject(joint)
            noImport = True

    if not noImport: #don't never use no double negatives

        import joint as FP
        import addonmanager_utilities as utils

        if FP.__version__ != __version__:
            writeFile()
            from PySide import QtCore,QtGui
            window = QtGui.QApplication.activeWindow()
            mbox = QtGui.QMessageBox()
            mbox.setWindowTitle(BASENAME+" updated")

            mbox.setText(BASENAME+".py has been updated to version "+__version__+". \
You must restart FreeCAD for the new changes to take effect and to use the macro.")
            mbox.setIcon(mbox.Warning)
            mbox.setStandardButtons(mbox.Ok | mbox.Cancel)
            mbox.setDefaultButton(mbox.Cancel)
            okBtn = mbox.button(QtGui.QMessageBox.StandardButton.Ok)
            cancelBtn = mbox.button(QtGui.QMessageBox.StandardButton.Cancel)
            okBtn.setText("Restart now")
            cancelBtn.setText("Restart later")
            ret = mbox.exec_()
            if ret == mbox.Ok:
                QtCore.QTimer.singleShot(1000, utils.restart_freecad)
        else:
            makeObject(FP)